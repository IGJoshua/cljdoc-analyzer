= cljdoc-analyzer

WARNING: PRE-ALPHA work here.

== Rationale

Return metadata for Clojure/ClojureScript projects for documentation purposes with the understanding that some projects might alter their metadata at load time.

cljdoc-analyzer's first use is for cljdoc but others might find use for this library as well.

== History

Some Clojure/ClojureScript projects alter their metadata at load time through tools such as https://github.com/ztellman/potemkin[potemkin import-vars].

https://github.com/weavejester/codox[Codox] was coded to understand altered metadata for the Clojure projects it documents.
Historically, cljdoc took advantage of these smarts via a branch on a fork of codox to get the metadata it to document Clojure/ClojureScript project apis. This branch also has an unmerged PR to that understands cljs import-vars type trickery.

This library is picks up from the cljdoc codox unmerged PR. It extracts the analysis portion of codox and leaves the rest behind.


== Design thoughts

* [ ] TODO: Move portions of this to a separate design history doc and other portions to main doc when/if things gel.

=== Potential others users
https://github.com/borkdude/clj-kondo[clj-kondo] is a static source analyzer. It has special coding to to understand the potemkin import-vars api, but it does not know about other metadata manipulations. The output of this tool might be useful for clj-kondo to fill in any gaps.

https://github.com/weavejester/codox[Codox] could potentially make use of this library.

=== Meeting the needs of cljdoc and others
cljdoc massages codox output to a the format it needs.  The format seems reasonable for general consumption.

==== current cldoc codox inputs:

cljdoc uses all options internally, none are exposed to project authors.

|====
|option key | codox usage | cljdoc usage | moving forward

| :language
| return metadata for `:clojure` or `:clojurescript`
| intelligently determines languages from source and calls codox once for each
| this still has merit if someone is only interested in one language, but we'll also add a new `:all` option for intelligent detection

| :root-path
| the github project root, used to calculate relative :source-paths
| sets to current dir (ie. had no use for this)
| if we want to remain general purpose, this concept still has use

| :source-paths
| the list of paths to search for source. When working from source and not a jar, this makes sense
| a single path: the root of exploded jar
| continue to support

| :namespaces
| a list of namespaces to include
| used internally by cljdoc
| continue to support

| :exception-handler
| behavior to execute on exception
| ditto
| continue to support

| :metadata
| a way to provide default metadata where it is missing
| unused
| <undecided>

| :writer
| a clever way to support different outputs, codox defaults to writing out html
| cljdoc uses 'clojure.core/identity to write out edn
| <undecided> continue to support, but default to spitting out edn (and nothing included to spit out anything else)

| :exclude-vars
| clj and cljs sometimes return data we are not interested in and this offers a way to exclude it, by default excludes record constructor functions returned by clj
| cljdoc uses default
| <undecided> we'll continue to exclude unwanted chaff, but do we need this to be configurable?
|====

==== current outputs
cljdoc codox currently treats clj and cljs as separate analysis passes. The returned analysis for a pass is a list of namespaces each with a list of public vars.
codox cljdoc skips namespaces and public elements tagged with `^:no-doc` metadata.


* codox analysis for a language is a list of maps of:
** `:name` namespace name
** `:doc` namespace doc string
** `:publics` namespace publics which is a list of maps of:
*** `:name` public element name
*** `:type` one of: `:macro` `:multimethod` `:protocol` `:var`
*** `:doc`  doc string
*** `:file` file relative to `:source-paths`
*** `:path`  file relative to `:root-path` returned as File object. Ignored by cljdoc; effectively the same as `:file` for analysis of an exploded jar
*** `:line` line number
*** `:arglists` list of vectors of arglists, omitted for `def` `record` and `protocol` elements
*** `:members`  only applicable when `:type` is `:protocol`, list of maps of:
**** `:arglists`  list of vectors of arglists
**** `:name` name of protocol method
**** `:type` TODO: can this be only `:var`?

special metadata tags when present are included:

* `:added` version an element was added
* `:deprecated` version an element was deprecated
* `:dynamic` for dynamic defs

cljdoc then takes this output and massages it to a map of:

* `:group-id` project group-id
* `:artifact-id` project artifact-id
* `:version` project version
* `:codox` codox analysis for languages which can consist of none, one or both of:
** `:clj` the above codox analysis for clojure with `:path` removed
** `:cljs` the above codox analysis for for clojurescript with `:path` removed
* `:pom-str` slurp of pom.xml


Think about:

* [ ] TO CONSIDER: a general purpose tool would not necessarily skip no-doc elements.
* [ ] TO EXPLORE: cljdoc codox and master codox retrieve project attributes differently.
* [ ] TO EXPLORE: is this a natural format for cljdoc or does it massage it further before rendering?

==== Usage
Because code is evaluated while getting metadata, cljdoc takes care to isolate this work by launching a separate process.

We'll continue to support the codox map of options, but let's be command line friendly as well. I think this could mean a main that accepts an options map from an edn file or from edn string.


== Testing

We make use of https://github.com/lambdaisland/kaocha[koacha] for testing


== Notes preserved from codox docs

=== AOT Compilation

AOT-compiled namespaces will lose their metadata, which mean you'll
lose documentation for namespaces. Avoid having global `:aot`
directives in your project; instead, place them in a specialized
profile, such as `:uberjar`.


=== namespace option

* [ ] TODO: what variants does cljdoc use?

The `:namespaces` option can be used to restrict the documentation to
a specific set of namespaces:

[source,clojure]
----
{:namespaces [library.core library.io]}
----

Regular expressions can also be used for more general matching:

[source,clojure]
----
{:namespaces [#"^library\."]}
----

For excluding only internal namespaces, it's sometimes useful to use
negative lookahead:

[source,clojure]
----
{:namespaces [#"^library\.(?!internal)"]}
----

To override the namespaces list and include all namespaces, use `:all`
(the default):

[source,clojure]
----
{:namespaces :all}
----

=== exclude-vars option
* [ ] TODO: hardcoded for cljdoc, do we want to continue to support?


The `:exclude-vars` option can be used to exclude vars that match a
regular expression. Set to `nil` to disable. By default vars generated
by record constructor functions are excluded (such as `->Foo` and
`map->Foo`):

[source,clojure]
----
{:exclude-vars #"^(map)?->\p{Upper}"}
----

=== metadata option
* [ ] TODO: not used by cljdoc

Codox constructs documentation from metadata on vars and namespaces.
You can specify a set of default metadata using the `:metadata` map:

[source,clojure]
----
{:metadata {:doc "FIXME: write docs"}}
----

=== writer option
* [ ] TODO: hardcoded for cljdoc

To use a different output writer, specify the fully qualified symbol of the
writer function in the `:writer` key:

[source,clojure]
----
{:writer codox.writer.html/write-docs}
----

== Metadata Options

To force Codox to skip a public var, add `:no-doc true`
to the var's metadata. For example:

[source,clojure]
----
;; Documented
(defn square
  "Squares the supplied number."
  [x]
  (* x x))

;; Not documented
(defn ^:no-doc hidden-square
  "Squares the supplied number."
  [x]
  (* x x))
----

You can also skip namespaces by adding `:no-doc true` to the
namespace's metadata. *This currently only works for Clojure code, not
ClojureScript.*

* [ ] TODO: really? let's check if this is still true.

For example:

[source,clojure]
----
(ns ^:no-doc hidden-ns)
----

To denote the library version the var was added in, use the `:added`
metadata key:

[source,clojure]
----
(defn square
  "Squares the supplied number."
  {:added "1.0"}
  [x]
  (* x x))
----

Similar, deprecated vars can be denoted with the `:deprecated`
metadata key:

[source,clojure]
----
(defn square
  "Squares the supplied number."
  {:deprecated "2.0"}
  [x]
  (* x x))
----


## Licenses

Largely based on codox:

* Copyright Â© 2018 James Reeves
* Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version.
