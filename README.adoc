= cljdoc-analyzer
:toc:
:toclevels: 4

WARNING: PRE-ALPHA work here.

== Rationale

A library to return metadata for source code in Clojure/ClojureScript projects with the understanding that metadata is
sometimes altered at load time.

cljdoc-analyzer's first use is for cljdoc but others might find value in this library as well.

== History

Some Clojure/ClojureScript projects alter their metadata at load time through tools such as
https://github.com/ztellman/potemkin[potemkin import-vars].

https://github.com/weavejester/codox[Codox] was coded to understand altered metadata for the Clojure projects it
documents. Historically, cljdoc took advantage of these smarts via a branch on a fork of codox to get the metadata it
needed to document Clojure/ClojureScript project apis. This branch also has an unmerged PR to that understands cljs
import-vars type metadata manipulation.

This library picks up from the cljdoc codox unmerged PR. It extracts the analysis portion of codox and leaves the rest
behind.

== Analysis & Design Ramblings

=== Questions & TODOS

In no specific order:

* [ ] TODO: Move portions of doc to a separate design history doc (or adr!) and other portions to main doc when/if
  things gel.
* [ ] Q: maintain specific support for analysis from source code repository? (as opposed to analysis from jar) (I'm currently
  thinking focus on jar support for initial releases)
* [ ] Q: do we want to keep the codox namespace? Could potentially make merges with codox master a bit easier? I'm
  thinking we should move to cljdoc-analyzer to encourage us to move ahead unfettered by the past. But this would also mean some
  adjustments to cljdoc. At the very least we'll still refer to generated edn as a codox data structure.
* [ ] TO EXPLORE: cljdoc specs describe codox data structure as namespaced to cljdoc.codox... is this used?
* [ ] TO CONSIDER: a general purpose tool would not necessarily skip no-doc elements.
* [ ] Q: turf `:exclude-vars` option?
* [ ] Q: turf `:metadata` option?
* [ ] Q: turf `:writer` option?
* [ ] Q: just curious, is protocol :members -> :type always :var?

=== Potential users
In addition to cljdoc, who else might find value in cljdoc-analyzer?

* https://github.com/borkdude/clj-kondo[clj-kondo] is a static source analyzer. It has special coding to to understand
  the potemkin import-vars api, but it does not know about other metadata manipulations. The output of this tool might
  be useful for clj-kondo to fill in any gaps.
* https://github.com/weavejester/codox[Codox] could potentially make use of this library, but at this time, the original
  author does not see a benefit (which is totally fine). So we'll not invest in maintaining codox compatibility.
* add hoc use. I (lread) am interested in using cljdoc-analyzer to compare api signatures between rewrite-clj,
  rewrite-cljs and rewrite-cljc to detect any unintended breakage and to document changes. (api comparison is also of
  interest for a future feature of cljdoc).

=== Analysis of current behavior

Codox was designed to allow authors to generate documentation for their Clojure/ClojureScript lein and boot projects. It
operates on the repository sources of a project and generates html.

Cljdoc does not follow the common codox use case. Cljdoc uses codox to retrieve api metadata only. It works on published
artifacts (jars) instead of repository sources (note that cljdoc does make use of the source repository for documentation
contained in articles, but codox does not come into play for this work).

Working at the published jar level instead of repository sources level means cljdoc:

* does not care whether a project uses leiningen, boot or deps tools, it simply refers to the source code contained
  in the jar, and the pom.xml.
* can assume the classpath for the source code in the jar is always at the exploded jar root.

That all said, when it comes down to it, the fundamental inputs for retrieval of metadata for both worlds are the same:

* classpath of sources and dependencies
* codox options

Because cljdoc works on unknown projects, it goes through some special steps to avoid potential problems with analysis.
And because code is evaluated while getting metadata, cljdoc takes care to isolate this work and minimize dependencies
by launching a separate process.

==== Tools support

Codox contains specific tool support for lein and boot.

Cljdoc does not make use of this support.

==== cljdoc jar processing steps

In a nutshell cljdoc analysis runner:

1. unzips the published jar to a work directory
2. removes problematic directories and files
3. copies over cljdoc wrapper source (which calls codox)
4. resolves classpath from pom (and includes extra deps as needed)
5. overrides languages and namespaces for problematic libraries
6. launches the cljdoc wrapper (which calls codox) for each found language with resolved classpath
7. merges codox language results into map for cljdoc consumption
8. saves results to an edn file to share back with cljdoc

A goal of these steps is to limit dependencies of the wrapper to Clojure core. The less dependencies our actual analysis
phase has, the less chance we have for project library collisions and confusions.

==== current cldoc codox inputs

cljdoc uses all options internally; none are exposed to project authors. The following table lists current option usages
and muses about what we might minimally and potentially support moving forward.

|====
|option key | codox usage | cljdoc usage | mimimally | potentially

| `:language`
| return metadata for `:clojure` or `:clojurescript`
| intelligently determines languages from source and calls codox once for each, with custom overrides for problematic projects
| continue to support
| -

| `:root-path`
| the github project root, used to calculate relative :source-paths
| sets to current dir (ie. had no use for this)
| if we are only supporting exploded jars, we could keep this and turf `:source-paths`
| if we want to remain general purpose, this concept still has use

| `:source-paths`
| the list of paths to search for source. When working from source and not a jar, this makes sense
| a single path, the root of exploded jar
| if we are only supporting exploded jars, we could keep `:root-path`  and turf this
| continue to support

| `:namespaces`
| a list of namespaces to include
| used by cljdoc to limit to specific namespaces for problematic projects, otherwise parse all.
| continue to support
| -

| `:exception-handler`
| behavior to execute on exception
| ditto
| turf and hardcode to current behavior
| continue to support for general usage

| `:metadata`
| a way to provide default metadata where it is missing
| unused
| turf it
| continue to support for general usage

| `:writer`
| a clever way to support different outputs, codox defaults to writing out html
| cljdoc uses 'clojure.core/identity to write out edn
| turf it, and hard code to return map only
| continue to support, but default to spitting out edn (and nothing included to spit out anything else)

| `:exclude-vars`
| clj and cljs sometimes return data we are not interested in and this offers a way to exclude it, by default excludes
  record constructor functions returned by clj
| cljdoc hardcodes to default
| turf it and hard code to current default
| continue to support, I wonder if any codox uses this...
|====

==== current outputs

Codox currently treats clj and cljs as separate analysis passes. The returned analysis for a pass is a list of
namespaces each with a list of public vars. Codox skips namespaces and public elements tagged with `^:no-doc` metadata.

* codox analysis for a language is a list of maps of:
** `:name` namespace name
** `:doc` namespace doc string
** `:publics` namespace publics which is a list of maps of:
*** `:name` public element name
*** `:type` one of: `:macro` `:multimethod` `:protocol` `:var`
*** `:doc`  doc string
*** `:file` file relative to `:source-paths`
*** `:path` file relative to `:root-path` returned as File object. Ignored by cljdoc; theoretically effectively the same
    as `:file` for analysis of an exploded jar
*** `:line` line number
*** `:arglists` list of vectors of arglists, omitted for `def` `record` and `protocol` elements
*** `:members`  only applicable when `:type` is `:protocol`, list of maps of:
**** `:arglists`  list of vectors of arglists
**** `:name` name of protocol method
**** `:type` can this be only `:var`?

special metadata tags when present are included:

* `:added` version an element was added
* `:deprecated` version an element was deprecated
* `:dynamic` for dynamic defs

cljdoc then takes this output and massages it to a map of:

* `:group-id` project group-id
* `:artifact-id` project artifact-id
* `:version` project version
* `:codox` codox analysis for languages which can consist of a map with none, one or both of:
** `:clj` the above codox analysis for clojure with `:path` removed
** `:cljs` the above codox analysis for for clojurescript with `:path` removed
* `:pom-str` slurp of pom.xml

This is serialized for later ingestion to a sqlite database by cljdoc. I do see some small tweaks by cljdoc here. Before
serialization it makes regexes in argslists serializable. After deserialization it sanitizes macros (which does
not really sanitize, it asserts no duplicate publics). An important observation is that while some map values get their
own columns in the db, edn is saved as a blob in the db, so preserving the edn structure will be important at the
individual var (aka public above) and namespace level.

=== Musings on new behavior

Unrefined thinking...

In its current fork of codox, I don't think cljdoc-analyzer is a candidate for a general purpose tool. There is too much
pre and post processing work. (I might be wrong here, review).

Ideally I think we'd give cljdoc analyzer a pointer to jar file it would return map of clj and cljs metadata. This
sounds like the current job of cljdoc's analysis runner.


== Testing

We make use of https://github.com/lambdaisland/kaocha[koacha] for testing


== Notes preserved from codox docs
Directly from codox README...

=== AOT Compilation

AOT-compiled namespaces will lose their metadata, which mean you'll
lose documentation for namespaces. Avoid having global `:aot`
directives in your project; instead, place them in a specialized
profile, such as `:uberjar`.


=== namespace option

The `:namespaces` option can be used to restrict the documentation to
a specific set of namespaces:

[source,clojure]
----
{:namespaces [library.core library.io]}
----

Regular expressions can also be used for more general matching:

[source,clojure]
----
{:namespaces [#"^library\."]}
----

For excluding only internal namespaces, it's sometimes useful to use
negative lookahead:

[source,clojure]
----
{:namespaces [#"^library\.(?!internal)"]}
----

To override the namespaces list and include all namespaces, use `:all`
(the default):

[source,clojure]
----
{:namespaces :all}
----

=== exclude-vars option

The `:exclude-vars` option can be used to exclude vars that match a
regular expression. Set to `nil` to disable. By default vars generated
by record constructor functions are excluded (such as `->Foo` and
`map->Foo`):

[source,clojure]
----
{:exclude-vars #"^(map)?->\p{Upper}"}
----

=== metadata option

Codox constructs documentation from metadata on vars and namespaces.
You can specify a set of default metadata using the `:metadata` map:

[source,clojure]
----
{:metadata {:doc "FIXME: write docs"}}
----

=== writer option

To use a different output writer, specify the fully qualified symbol of the
writer function in the `:writer` key:

[source,clojure]
----
{:writer codox.writer.html/write-docs}
----

== Metadata Options

To force Codox to skip a public var, add `:no-doc true`
to the var's metadata. For example:

[source,clojure]
----
;; Documented
(defn square
  "Squares the supplied number."
  [x]
  (* x x))

;; Not documented
(defn ^:no-doc hidden-square
  "Squares the supplied number."
  [x]
  (* x x))
----

You can also skip namespaces by adding `:no-doc true` to the
namespace's metadata.

For example:

[source,clojure]
----
(ns ^:no-doc hidden-ns)
----

To denote the library version the var was added in, use the `:added`
metadata key:

[source,clojure]
----
(defn square
  "Squares the supplied number."
  {:added "1.0"}
  [x]
  (* x x))
----

Similar, deprecated vars can be denoted with the `:deprecated`
metadata key:

[source,clojure]
----
(defn square
  "Squares the supplied number."
  {:deprecated "2.0"}
  [x]
  (* x x))
----


## Licenses

Based on https://github.com/weavejester/codox[Codox]:

* Copyright © 2018 James Reeves
* Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version.
